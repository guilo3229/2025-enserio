<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>Fundamentos Javascrpt</h1>
    <ul>
      <li>Primavera</li>
      <li>Verano</li>
      <li>Otoño</li>
      <li>Invierno</li>
    </ul>
    <script>
      // var hola = "Hola mundo";
      // let hello = "hello world";
      // console.log(hola);
      // console.log(hello);
      // console.log(window);
      // console.log(window.hola);
      // console.log(window.hello);
      // if (true) {
      // }
      // // Ambito de bloque
      // // Esto es un bloque - comentario de una linea
      // console.log("*********var*********");
      // var musica = "Rock";
      // console.log("Variable Musica antes del bloque", musica);

      // // {
      // //   var musica = "pop";
      // //   console.log("Variable Musica dentro del bloque", musica);
      // // }
      // // console.log("Variable Musica despues del bloque", musica);
      // // console.log("*********let*********");
      // // let musica2 = "Rock";
      // // console.log("Variable Musica antes del bloque", musica2);

      // // {
      // //   let musica2 = "pop";
      // //   console.log("Variable Musica dentro del bloque", musica2);
      // // }
      // // console.log("Variable Musica despues del bloque", musica2);
      // const PI = 3.1416;
      // console.log(PI);
      // // Usaremos const cuando nuestra variable no vaya a cambiar el valor durante el flujo de nuestra aplicacion
      // // No puedes tener constantes vacias con var y con let si dejaria
      // // const NUEVE;
      // let a;
      // console.log(a);
      // a = "Kenai";
      // console.log(a);
      // // PI = 3.15;
      // //
      // const objeto = {
      //   nombre: "jon",
      //   edad: 35,
      // };
      // const colores = ["blanco", "negro", "azul"];
      // console.log(objeto);
      // console.log(colores);
      // objeto.correo = "jonmmircha@gmail.com";
      // colores.push("anaranjado");
      // console.log(objeto);
      // console.log(colores);
      // // Con valores compuestos como objetos o arrays como tal no entramos al valor directamente sino a una referencia de este objeto es decir sigue siendo un objeto o los arreglos, en primitivos no vas a poder cambiarlos con const sin embargo con objetos y arrays si que vas a poder modificarlo
      // // Si a lo largo del tiempo de la ejecucion de tu aplicacion se va a modificar el tipo de valor usa let sino , puedes usar const

      // // Cadenas de Texto aka Strings
      // let nombre = "Jon";
      // let apellido = "MirCha",
      //   Saludo = new String("Hola mundo"),
      //   lorem =
      //     "      No hay nadie que ame el dolor mismo, que lo busque, lo encuentre y lo quiera, simplemente porque es el dolor           ";
      // console.log(nombre, apellido, Saludo);
      // console.log(
      //   nombre.length,
      //   apellido.length,
      //   Saludo.length,
      //   nombre.toUpperCase(),
      //   apellido.toLowerCase(),
      //   lorem.includes("hay"),
      //   lorem.includes("casa"),
      //   // Con el metodo trim sirve para quitar los espacios inecesarios al principio y al final
      //   lorem,
      //   lorem.trim(),
      //   // Con el metodo split separa en un array la cadena de texto y la norma la dicta separador que le pongamos dentro y crea un elemento entre cada separador de estos, sin incluir dicho separador cuando muestra los elementos en el array del console.log
      //   lorem.split(" "),
      //   lorem.split(",")
      //   // Propiedades->Son caracteristicas y atributos
      //   // metodos-> Acciones o funciiones que nos vana a permitir ejecutar algo
      // );

      // let nombre = "Jon",
      //   apellido = "Mircha",
      //   // Concatenacion
      //   saludo = "Hola mi nombre es " + nombre + " " + apellido;
      // console.log(saludo);
      // // Interpolacion de variables-> que significa? meter dentro de una cadenta de texto el valor dinamicamente de una variable
      // // Template String
      // let saludo2 = `Hola mi nombre es ${nombre} ${apellido}.`;
      // console.log(saludo2);
      // let ul =
      //   "    <ul><li>Primavera</li><li>Verano</li><li>Otoño</li><li>Invierno</li></ul>";
      // console.log(ul);
      // // las `` si nos permite hacerlo de la manera de abajo respetandote las cosas y los espacios, con las "" no dejaria al igual que pasa con ${}
      // let ul2 = `
      // <ul>
      //   <li>Primavera</li>
      //   <li>Verano</li>
      //   <li>Otoño</li>
      //   <li>Invierno</li>
      // </ul>
      // `;
      // console.log(ul2);
      // let ul3 = " <ul>";
      // ul3 += " <li> Primavera</li>";
      // ul3 += " <li>Verano</li>";
      // ul3 += " <li>Otoño</li>";
      // ul3 += " <li>Invierno</li>";
      // ul3 += " </ul>";
      // console.log(ul3);

      // // numeros->numbers
      // let a = 2,
      //   b = new Number(1),
      //   c = 7.19;
      // let d = "5.6";
      // console.log(a, b);
      // // El metodo toFixed() sirve para decirle el numero de decimales maximos que quieres que te muestre el numero decimal
      // console.log(c.toFixed(0));
      // console.log(c.toFixed(5));
      // // Con ParseInt conun numero te devuelve la parte entera
      // console.log(parseInt(c));
      // // Con parseFloat te devuelve todo el valor del numero incluyendo decimales
      // console.log(parseFloat(c));
      // console.log(typeof c, typeof d);
      // console.log(a + b);
      // console.log(c + d);
      // // Para pasar de un  valor cadena de texto a valor numeico se puede hacer con parseInt, pero solo sumara el numero entero
      // console.log(c + parseInt(d));
      // console.log(c + parseFloat(d));
      // console.log(c + Number.parseInt(d));
      // console.log(c + Number.parseFloat(d));
      // let verdadero = true,
      //   falso = false,
      //   v = Boolean(true),
      //   f = Boolean(false);
      // console.log(verdadero, falso, v, f);
      // console.log(typeof verdadero, typeof falso);
      // // El valor 0 dentro de los Booleanos es false
      // console.log(Boolean(0));
      // // El valor 0 dentro de los Booleanos es false
      // // Cadena de texto vacia tiende a false
      // console.log(Boolean(""));
      // // Sin embargo en cuanto tenga cualquier caracter espacio etc tiende a true aunque esta cadena de texto sea 0
      // console.log(Boolean("0"));
      // //  En esta pagina podemos ver los valores que tienden a verdadero o falso respecto a Boolean -> https://developer.mozilla.org/en-US/docs/Glossary/Truthy
      // // Para falso-> https://developer.mozilla.org/en-US/docs/Glossary/Falsy

      // Tanto null como undefind vana indicicar un valor ausente algo que no tiene valor, pero la gran diferencia es que algo que no esta inicializa es decir que no se le ha asignado ningun valor a la hora que se creo
      // let indefinida;
      // console.log(indefinida);
      // Null es un valor puesto intencionalmente por el programador sin embargo undefined es aplicado por JavaScript cuando no se ha definido dicha variable cuando se crea
      // let nulo = null;
      // // Undefined indica que no se ha inicializado una variable y que el valor esta ausente
      // // null es un valor especial que indica la ausencia de un valor

      // // NaN - Not a Number
      // let noEsUnNumero = "hola" * 3.7;
      // console.log(noEsUnNumero);

      /*
      Una funcion es un bloque de codigo
      autocontenido, que se puede definir una vez y ejecutar en cualquier momento.Opcionalmente, una funcion puede aceptar parametros y devolver un valor

      las funciones en JavaScript son objetos,un tipo especial de objetos.

      Se dice que las funcioens son ciudadanos de primera clase porque pueden asignarse a un valor, y pueden pasarse como argumentos y usarse como un valor de retorno
      */

      // Funciones Declarada
      // Declaracion de función
      // function estoEsUnaFuncion() {
      //   console.log("Uno");
      //   console.log("Dos");
      //   console.log("Tres");
      //   return "La funcion ha retornado una Cadena de texto";
      // }
      // // Invocacion de función
      // // estoEsUnaFuncion();
      // // estoEsUnaFuncion();
      // // estoEsUnaFuncion();
      // // estoEsUnaFuncion();
      // function unaFuncionQueDevuelveValor() {
      //   console.log("Uno");
      //   return 19;
      //   console.log("Dos");
      //   console.log("Tres");
      //   return "La funcion ha retornado una Cadena de texto";
      // }
      // // let valorDeFuncion = unaFuncionQueDevuelveValor();
      // // console.log(valorDeFuncion);
      // function saludar(nombre = "Desconocido", edad = 0) {
      //   console.log(`Hola mi nombre es ${nombre} y tengo ${edad} años`);
      // }
      // saludar("kEnai", 7);
      // saludar();
      // // Funciones declaradas VS funciones expresadas

      // funcionDeclarada();
      // // Lo que hace Javascript con las funciones declaradas las manda arriba justo despues de las variables, las eleva hooisting
      // function funcionDeclarada() {
      //   console.log(
      //     "Esto es una funcion declarada ,puede invocarse en cualquier parte de nuestro codigo,incluso antes de que la funcion sea declarada"
      //   );
      // }
      // funcionDeclarada();

      // // funcionExpresada();
      // // Función anónima(Expresada por asignarsela a una variable)
      // const funcionExpresada = function () {
      //   console.log(
      //     "Esto es una funcion expresada es decir, una funcion que se le ha asignado como valor a una variable, si invocamos esta función antes de su definicion JS nos dirá...'Cannot access 'funcionExpresada' before initialization ' "
      //   );
      // };
      // funcionExpresada();
      // const a = [],
      //   b = [1, true, "hola", ["A", "B", [1, 2, 3]]];
      // console.log(a);
      // console.log(b);
      // console.log(b.length);
      // console.log(b[2]);
      // console.log(b[0]);
      // console.log(b[3][2][0]);
      // const c = Array.of("X", "Y", "Z", 9, 8, 7);
      // console.log(c);
      // // Si quiero tener un ARray con un numero determinado de valores, lo podemos poner despues del metodo Array() y ya si queremos un valor predeterminado para estos podemos relletarlos con este valor usando .fill() posteriormente del Array()-> Array().fill()
      // const d = Array(100).fill(false);
      // console.log(d);
      // // No se usa lo de new Array()
      // const e = new Array();
      // console.log(e);
      // const f = new Array(1, 2, 3, true, false);
      // console.log(f);
      // //Metodos del Array
      // const colores = ["rojo", "verde", "azul"];
      // console.log(colores);
      // // Por ejemplo el metodo push, por defecto el metodo push añadira al final el elemento escrito con ese método
      // colores.push("Negro");
      // console.log(colores);
      // // metodo .pop() Elimina el ultimo valor del array quedando con una longitud -1
      // colores.pop();
      // console.log(colores);
      // // Metodo forEach ->una de sus funciones nos srive para aplicar una funcion por cada elemento del Array
      // // El valor de de dentro del parentesis detras de funtion sera el elemento que se esta iterando en ese momento, luego se e aplicara  lo que esta entre llaves, el segundo valor que se le da es el valor index del array es decir la posicion que tiene el elemento del array que esta iterando, si ponemos un tercer valor sera el array completo, no tiene un cuarto valor solo 3, el primero para el elemento el segundo seria la posicion del elemento y el tercero seria el Array completo
      // colores.forEach(function (el, s, r) {
      //   console.log(`<li id ="${s}" mod="${r}">${el}<li>`);
      // });
      // let a = new String();
      // // console.log(a);
      // // Al definir mis objejtos con const evito que otro objeto ocupe la referencia de momoria de mi objeto
      // const b = {};
      // console.log(b);
      // // No es recomendable usar el contructor en general lo de new objetc, new string etc son malas practicas
      // const c = new Object();
      // console.log(c);
      // const jon = {
      //   nombre: "Jon",
      //   apellido: "Mircha",
      //   edad: 35,
      //   pasatiempos: ["Correr", "hacer ejercicio", "Dar clases"],
      //   soltero: false,
      //   contacto: {
      //     email: "jonmircha@gmail.com",
      //     twitter: "@jonmircha",
      //     movil: 5212543245,
      //   },
      //   saludar: function () {
      //     console.log(`Hola :)`);
      //   },
      //   decirMiNombre: function () {
      //     console.log(
      //       `Hola me llamo ${this.nombre} ${this.apellido} y tengo ${this.edad} años y me puedes seguir como ${this.contacto.twitter}`
      //     );
      //   },
      // };
      // console.log(jon);
      // console.log(jon["nombre"]);
      // console.log(jon["apellido"]);
      // // Para ver las propiedades o atributos de un objeto es mejor a traves del . aunque tambien se puede entrar o hacer referencia a traves de corchetes,saludar seria un meodo o funcion

      // // Importante dentro de un objeto a las variables se les va a llamar atributos o propiedades y a las funciones se les llama métodos
      // console.log(jon.nombre);
      // console.log(jon.apellido);
      // console.log(jon.edad);
      // console.log(jon.soltero);
      // console.log(jon.pasatiempos[1]);
      // console.log(jon.contacto.twitter);
      // jon.saludar();
      // jon.decirMiNombre();
      // // Object.keys(objeto que quiero) nos da uin metodo que nos muestra en un array las diferentes propiedades(atributos) y metodos(funciones) de objeto puesto entre parentesis
      // console.log(Object.keys(jon));
      // // Con values es igual que lo anterior pero nos da los valores da cada propiedad(atributo) y funcion(metodo)
      // console.log(Object.values(jon));
      // // Para saber si un objeto tiene una propuiedad(atributo) o funcion(metodo) dentro de este se buscaria usanfo hasOwnProperty y entre comillas dicha propiedad
      // console.log(jon.hasOwnProperty(`nombre`));
      // console.log(jon.hasOwnProperty(`nacimiento`));
      /* Operadores */
      /* Aritméticos: + - % () * */
      // let a = 5 + (5 - 10) * 3;
      // let modulo = 5 % 2;
      // console.log(a);
      // console.log(modulo);
      // /* Relacionales
      // >, <, >=, <=, ==, ===, !=, !==

      // */
      // console.log(8 > 9);
      // console.log(9 > 8);
      // console.log(8 >= 9);
      // console.log(9 >= 8);
      // console.log(7 < 7);
      // console.log(7 <= 7);

      /*
      = 1 igual es asignacion de variable
      == 2 iguales es comparacion de valores
      === 3 iguales es comparacion de tipo de dato y valor(la mas recomendable) */

      // console.log(7 == 7);
      // console.log("7" == 7);
      // console.log(0 == false);
      // console.log("*********");
      // console.log(7 === 7);
      // console.log("7" === 7);
      // console.log(0 === false);

      // // Incremento Decremento

      // let i = 2;
      // // console.log(i++);
      // console.log(++i);
      // i = i + 2;
      // i *= 3;

      // Operador unario
      // i++;
      // i--;
      // ++i;
      // --i;
      // Lógicos
      /*
      !not: nie, es ddecir lo que es verdadero lo vuelve falso y viceversaga
      || Or -> Cuando tengo 2 o msa condiciones, con que una se cumpla , es decir sea verdadera, el OR validará
      && And -> Cuando tengo 2 o mas condiciones , todas tienen que cumplirse es decir que todas sean verdaderas para que AND se valida es decir sea true
      */
      // console.log(!true);
      // console.log(!false);
      // console.log(9 === 9 || "9" === 9);
      // console.log(9 === 9 && "9" === 9);
      // console.log(9 === 9 && "9" === "9");
      // if - else

      // let edad = 18;

      // if (edad > 17) {
      //   console.log("Eres mayor de Edad");
      // } else {
      //   console.log("Eres menor de Edad");
      // }
      // if (edad >= 18) {
      //   console.log("Eres mayor de Edad");
      // } else {
      //   console.log("Eres menor de Edad");
      // }
      // if (edad < 18) {
      //   console.log("Eres menor de Edad");
      // } else {
      //   console.log("Eres mayor de Edad");
      // }
      // // if - else if - else
      // /* Buenos dias 6am - 11am
      // Buenas tardes 12hrs  18hrs
      // Buenas noches 19hrs -23hr
      // Dejame dormir - 0hrs - 5hrs */
      // let hora = 18;
      // if (hora >= 0 && hora <= 5) {
      //   console.log("Dejame dormir");
      // } else if (hora >= 6 && hora <= 11) {
      //   console.log("Buenos dias");
      // } else if (hora >= 12 && hora <= 18) {
      //   console.log("Buenas tardes");
      // } else {
      //   console.log("Buenas noches");
      // }
      // if (hora > 0 && hora < 6) {
      //   console.log("Dejame dormir");
      // } else if (hora > 5 && hora < 12) {
      //   console.log("Buenos dias");
      // } else if (hora > 11 && hora < 19) {
      //   console.log("Buenas tardes");
      // } else {
      //   console.log("Buenas noches");
      // }

      // // Operador Ternario(condicion)?verdadero:falsa-> En un operador ternario solo puedes ejecutar una linea de codigo
      // console.log(" Operador ternario");
      // //  prettier-ignore
      // let eresMayor = edad >= 18
      // ? "eres mayor de Edad"
      // : "Eres menor de edad";

      // console.log(eresMayor);
      // switch - case lo vamos a necesitar para diferentes valores para una misma variable
      /*
      Domingo - 0
      Lunes - 1
      Martes - 2
      Miercoles - 3
      Jueves - 4
      Viernes - 5
      Sabado -
       6 */
      // let dia = 20;
      // switch (dia) {
      //   case 0:
      //     console.log("Domingo");
      //     // Si no ponemos el break en  cada caso seguira pasando al siguiente hasta encontrar un break
      //     break;
      //   case 1:
      //     console.log("Lunes");
      //     break;
      //   case 2:
      //     console.log("Martes");
      //     break;
      //   case 3:
      //     console.log("Miercoles");
      //     break;
      //   case 4:
      //     console.log("Jueves");
      //     break;
      //   case 5:
      //     console.log("viernes");
      //     break;
      //   case 6:
      //     console.log("Sabado");
      //     break;

      //   default:
      //     console.log("El dia no existe");
      //     break;
      // }
      // let contador = 10;
      // let contador2 = 10;
      // while (contador < 10) {
      //   console.log("while " + contador);
      //   contador++;
      // }
      // Con do primero entra ejerce lo la funcion que sea, al menos se va a ejecutar una vez todo el codigo y luego evalua con while primero evalua y si cumple entra, estas son pocos usadas es mejor usar el for
      // do {
      //   console.log("do while " + contador2);
      //   contador2++;
      // } while (contador2 < 10);
      // Dentro de los parentesis del for viene la inicizlizacion de la variable;condicion;decremento o incremento{sentencias que ejecuta el for}
      // for (let i = 0; i < 10; i++) {
      //   console.log("for " + i);
      // }
      // let numeros = [10, 20, 30, 40, 50, 60, 70, 80, 90];
      // for (i = 0; i < numeros.length; i++) {
      //   console.log(numeros[i]);
      // }
      // const jon = {
      //   nombre: "Jon",
      //   apellido: "Mircha",
      //   edad: 35,
      // };
      // // El for in nos permite recorrer solamente proiedades de un objeto
      // for (const propiedad in jon) {
      //   console.log(`key: ${propiedad}, Value: ${jon[propiedad]}`);
      // }
      // // El for o of nos permite recorrer todos los elmentos de cualquier valor iterable de javascript
      // for (const elemento of numeros) {
      //   console.log(elemento);
      // }
      // let cadena = "hola mundo";
      // for (const caracter of cadena) {
      //   console.log(caracter);
      // }
      // // // No funciona con objetos
      // // for (const caracter of jon) {
      // //   console.log(caracter);
      // // }

      // try {
      //   console.log("En el try se agrega el código a evaluar");
      //   // No definir una variable lo considera un error y pasaria al catch.
      //   noExiste;
      //   console.log("Segundo mensaje en el try");
      // } catch (error) {
      //   console.log("catch captura cualquier error surgido en el try");
      //   console.log(error);
      // } finally {
      //   console.log(
      //     "El bloque finally se ejecutara siempre al final de un bloque try-catch"
      //   );
      // }
      // try {
      //   let numero = "y";
      //   if (isNaN(numero)) {
      //     throw new Error("El caracter introducido no es un numero");
      //   }
      //   console.log(numero * numero);
      // } catch (error) {
      //   console.log(`Se ptrodujo el siguiente error: ${error}`);
      // } finally {
      //   // Por ejemplo el finally se puede usar para el lado del backend por ejemplo cuando se finalice la apertura de un archivo sea error o no cerrar ese archivo
      //   console.log(
      //     "El bloque finally se ejecutara siempre al final de un bloque try-catch"
      //   );
      // }

      // const numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
      // // la palabra break y continue no se puede usar con los metodos de los arreglos como el forEach
      // for (let i = 0; i < numeros.length; i++) {
      //   if (i === 5) {
      //     // Con el break nos salimos de la estructura en la que estamos
      //     break;
      //   }
      //   console.log(numeros[i]);
      // }
      // for (let i = 0; i < numeros.length; i++) {
      //   if (numeros[i] % 2 > 0) {
      //     // Con continue simplemente omite, se salta esa iteracion y sigue con la siguiente de nuetra estructura de control y sigue cumpliendo con las demasd iteraciones en este caso del bucle for, no funciona con metodos de los arrays
      //     continue;
      //   }
      //   console.log(numeros[i]);
      // }
      // for (let i = 0; i < numeros.length; i++) {
      //   if (numeros[i] % 2 === 0) {
      //     // Con el break nos salimos de la estructura en la que estamos
      //     continue;
      //   }
      //Sin destructuracion
      // const numeros = [1, 2, 3];
      // let uno = numeros[0],
      //   dos = numeros[1],
      //   tres = numeros[2];
      // console.log(uno, dos, tres);
      // Con destructuracion
      // Con arrays es entre corchetes y con objetos es entre llaves, ojo que igual si hacemos un array de letras de un string tambien seria como un array y habria que usar corchetes
      // const [one, two, three] = numeros;
      // console.log(one, two, three);
      // const persona = {
      //   nombre: "Jon",
      //   apellido: "Mircha",
      //   edad: "35",
      // };
      // //Pera desestructurar el valor que nos da tiene que ser igual dentro de llaves al nombre de la propiedad dentro del objeto esto nos dara sus valores de dichas propiedades si no coincide con su valor no funciona, anuque yo modifique el orden de las variables las busca y les da su valor correspendiente
      // let { nombre, apellido, edad } = persona;
      // console.log(nombre, apellido, edad);
      // let nombre = "Kenai",
      //   edad = 7;
      // const perro = {
      //   nombre: nombre,
      //   edad: edad,
      //   ladrar: function () {
      //     console.log("guauu guauuu!!!");
      //   },
      // };
      // console.log(perro);
      // perro.ladrar();
      // const dog = {
      //   // Al poner solamente la propiedad entendera ue  nombre: nombre que tienen el mismo  nombre valga la redundancia
      //   nombre,
      //   edad,
      //   raza: "Callejero",
      //   // funcion dentro de objeto que seria un metodo  se simplificaria de esta manera
      //   ladrar() {
      //     console.log("guauu guauuu!!! guaaau!!");
      //   },
      // };
      // dog.ladrar();
      // El poner ...c es como decir el parametro Rest que significa que puedes meter los paraemtros que quieras, el parametro REST es un array siempre
      // function sumar(a, b, ...c) {
      //   let resultado = a + b;
      //   console.log(c);
      //   c.forEach(function (n) {
      //     resultado += n;
      //   });
      //   return resultado;
      // }
      // console.log(sumar(1, 2));
      // const arr1 = [1, 2, 3, 4, 5],
      //   arr2 = [6, 7, 8, 9, 0];
      // console.log(arr1, arr2);
      // const arr3 = [...arr1, ...arr2];
      // console.log(arr3);
      // Funcion expresada la ejecucion no puede ser antes de que se declare  dicha funcion
      // const saludar = function () {
      //   console.log("hola expresada");
      // };
      // saludar();
      // saludar2();
      // // En las funciones declarada el hoisting manda arriba la funcion justo despues de las const y puede ser ejecutada antes de programarla
      // function saludar2() {
      //   console.log("hola declarada");
      // }
      // // Una arrow function es quitar la palabra funtion en la expresada y entre el parentesis y la llave poner una flechita
      // // Las funciones de flecha tambien son expresadas
      // const saludar3 = () => {
      //   console.log("saludo 3");
      // };
      // saludar3();
      // // Si es solo una linea de ejecucion podemos omitir las llaves y dejarla tal que:
      // const saludar4 = () => console.log("saludo 4");
      // saludar4();
      // //Cuando una funcion flecha recibe 1 paremetro no es necesario los parentesis, para mas de 1 parametro si es necesario separados por comas ,
      // //  prettier-ignore
      // const saludar5 = nombre => console.log(`Hola ${nombre}`);
      // saludar5("Irma");
      // // Tambien funciona sin los corchetes aunque dejes las llaves en las funciones expresadas de flecha
      // //  prettier-ignore
      // const saludar6 = nombre => {
      //   console.log(`Hola ${nombre}`);
      // };
      // saludar6("pepe");

      // const sumar = function (a, b) {
      //   return a + b;
      // };
      // console.log(sumar(8, 9));
      // // simplificado:
      // const sumare = (a, b) => a + b;
      // console.log(sumare(3, 5));

      // const funcionDeVariasLineas = () => {
      //   console.log("Uno");
      //   console.log("Dos");
      //   console.log("Tres");
      // };
      // funcionDeVariasLineas();
      // const numeros = [1, 2, 3, 4, 5];

      // numeros.forEach(function (el, index) {
      //   console.log(`Posicion:${index} valor:${el}`);
      // });
      // // Tambien puedo hacerla como una arrow function ya que queda hasta mas expresivo
      // numeros.forEach((el, index) =>
      //   console.log(`Posicion:${index} valor:${el}`)
      // );
      // // function Perro() {
      // //   console.log(this);
      // // }
      // // Perro();
      // const perro = {
      //   nombre: "Kenai",
      //   ladrar: function () {
      //     console.log(this);
      //   },
      // };
      // const perro2 = {
      //   nombre: "Kenai",
      //   // Si le pongo el this a una funcion como metodo dentro del objeto me saca al this del objeto window saltandose al objeto y el contexto que esta y heredar el contexto padre donde ha sido declarado, por ejemplo no podria poner this.nombre porque pasaria al contexto dinwo saltandose el objeto
      //   ladrar: () => {
      //     console.log(this);
      //   },
      // };
      // perro2.ladrar();
      // const perro3 = {
      //   nombre: "Kenai",
      //   // Quitando los  2 puntos y el function es la mejor manera mas simple y no te cargas el contexto con el this de la arrow function
      //   ladrar() {
      //     console.log(this);
      //   },
      // };
      // perro3.ladrar();

      // POO
      /*
      Clases - Modelos a seguir
      Objetos - Es una instancia de una clase, la instancia es la copia del modelo a seguir
      Atributos - Es una caracterstica o propiedad del objeto(Son variable dentro de un objeto)
      Métodos - Son las acciones que un objeto puede realizar(son las funciones dentro de un objeto)
      */
      // const animal = {
      //   nombre: "Snoopy",
      //   sonar() {
      //     console.log("Hago sonidos porqur stoy vivo");
      //   },
      // };
      // const animal2 = {
      //   nombre: "Lola Bunny",
      //   sonar() {
      //     console.log("Hago sonidos porqur stoy vivo");
      //   },
      // };
      // console.log(animal);
      // console.log(animal2);

      // // Funcion constructora
      // // De la cual vamos a crear un prototipo
      // function Animal(nombre, genero) {
      //   // Cuando estemos trabajando con funciones constructoras tanto los atributos como los metodos hay que colgarlos del this:
      //   // Los atributos si que deben estar dentro de la funcion constructora pero los metodos habra que pegarlos al prototipo  para que no se dupliquen estos  cada vez que haga una instancia.
      //   // Atributos
      //   this.nombre = nombre;
      //   this.genero = genero;
      //   // Metodos
      //   this.sonar = function () {
      //     console.log("Hago sonidos porque estoy vivo");
      //   };
      //   this.saludar = function () {
      //     console.log(`Hola me llamo: ${this.nombre}`);
      //   };
      // }
      // // Funciio constructura donde asignamos los metodos a los protootipos no a neustra funcion constructora
      // function Animal(nombre, genero) {
      //   // Cuando estemos trabajando con funciones constructoras tanto los atributos como los metodos hay que colgarlos del this:
      //   // Los atributos si que deben estar dentro de la funcion constructora pero los metodos habra que pegarlos al prototipo  para que no se dupliquen estos  cada vez que haga una instancia.
      //   // Atributos
      //   this.nombre = nombre;
      //   this.genero = genero;
      // }
      // // Metodos asignados por fuera al prototipo, con esto encontraremos los metodos en el prototipo no en el constructor, con esto hacemos una mejora en el rendimiento bastante grande
      // Animal.prototype.sonar = function () {
      //   console.log("Hago sonidos porque estoy vivo");
      // };
      // Animal.prototype.saludar = function () {
      //   console.log(`Hola me llamo: ${this.nombre}`);
      // };
      // // New nos permitia crear una nueva instancia de un string array , numero desde el punto de vista objeto normalmente pera estas variable no poniamamos new pero para que se pueda crear un nuevo objeto a traves de una funcion constructora lo usaremos

      // // Herencia prototípica
      // function Perro(nombre, genero, tamanio) {
      //   this.super = Animal;
      //   this.super(nombre, genero);
      //   this.tamanio = tamanio;
      // }
      // // Perro esttá heredando de Animal
      // Perro.prototype = new Animal();
      // Perro.prototype.contructor = Perro;

      // // Sobreescritura de métodos del Prototipo padre en el hijo
      // Perro.prototype.sonar = function () {
      //   console.log("Soy un perro y mi sonido es ladrido");
      // };
      // Perro.prototype.ladrar = function () {
      //   console.log("Guau Guau");
      // };
      // const snoopy = new Perro("Snoopy", "Perro", "Mediano"),
      //   lolaBunny = new Animal("Lola Bunny", "hembra");
      // console.log(snoopy);
      // console.log(lolaBunny);
      // snoopy.sonar();
      // snoopy.saludar();
      // snoopy.saludar();
      // snoopy.ladrar();

      // lolaBunny.sonar();
      // lolaBunny.saludar();

      // Lo haremos con azucar sintactico(clases dentro de javascript que entre vanvalinas lo prototipa etc)
      //   class Animal {
      //     // Para poder meter parametros  las clases tienen un metodo llamado contructor.
      //     // El constructor es un método especial que se ejecuta en el momento de instanciar la clase.
      //     // Atributos
      //     constructor(nombre, genero) {
      //       this.nombre = nombre;
      //       this.genero = genero;
      //     }
      //     // Metodos
      //     // En este caso no hay que sacarlos para que no se dupliquen y generen carga en la app, JavaScript ya lo hace automaticamente al hacerlo con formato de clase(class)
      //     sonar() {
      //       console.log("Hago sonidos porque estoy vivo");
      //     }
      //     saludar() {
      //       console.log(`Hola me llamo ${this.nombre}`);
      //     }
      //   }
      //   class Perro extends Animal {
      //     constructor(nombre, genero, tamanio) {
      //       // En este caso no tiengo que asignarle a una variable el valor de super, sino que es un metodo que llama directamente a la clase padre
      //       super(nombre, genero);
      //       this.tamanio = tamanio;
      //       this.raza = null;
      //     }
      //     // Sobreescritura dentro de la extension (herencia) de la clase, se pone dentro de las llaves class pero fuera del contructor, dentro del constructor solo parametros:
      //     sonar() {
      //       console.log("Soy un perro y mi sonido es un ladrido");
      //     }
      //     ladrar() {
      //       console.log("GUAGUAU!!");
      //     }
      //     // Un método estáticao es el cual se puede ejecutar sin necesidad de instanciar la clase
      //     static queEres() {
      //       console.log(
      //         "Los perros somos animales mamíferos que pertenecemos a la familia de los caninos somos considerados los mejores amigos del hombre"
      //       );
      //     }
      //     // Los setters y getters son métodos especiales que nos permiten estabklecer y obtener los valores de atributos de  nuestr clase
      //     get getRaza() {
      //       return this.raza;
      //     }
      //     set setRaza(raza) {
      //       this.raza = raza;
      //     }
      //   }
      //   Perro.queEres();
      //   const mimi = new Animal("mimi", "hembra"),
      //     scooby = new Perro("Scoob", "Macho", "gigante");
      //   console.log(mimi);
      //   mimi.saludar();
      //   mimi.sonar();
      //   console.log(scooby);
      //   scooby.saludar();
      //   scooby.sonar();
      //   scooby.ladrar();
      //   // getRaza al ser un getter es como si fuera un atributo no un metodo
      //   console.log(scooby.getRaza);
      //   // scooby.getRaza();
      //   // Lo mismo pasa con el setRaza
      //   scooby.setRaza = "Gran Danes";
      //   console.log(scooby.getRaza);
      //

      // console.log(console);
      // console.error("Esto es un error");
      // console.warn("Esto es un aviso");
      // console.info("Esto es un mensaje informativo");
      // console.log("Un registro de lo que ha pasado en nuestra aplicación");
      // let nombre = "jon",
      //   apellido = "Mircha",
      //   edad = 35;
      // console.log(nombre);
      // console.log(apellido);
      // console.log(edad);
      // console.log(nombre, apellido, edad);
      // console.log(
      //   `Hola mi nombre es ${nombre} ${apellido} y tengo ${edad} años.`
      // );
      // // Tambien se pueden hacer como sustitucion de comodines %s para string y %d para number
      // console.log(
      //   `Hola mi nombre es %s %s y tengo %d años.`,
      //   nombre,
      //   apellido,
      //   edad
      // );
      // // Para limpiar la consola usamos console.clear()
      // console.clear();
      // console.log(window);
      // // El document es la representacion HTML a traves de JavaScript
      // console.log(document);
      // // El document.dir nos muestra todos los atributos,metodos etc que tiene el document
      // console.dir(document);
      // console.log(document.body);
      // console.clear();
      // // Para abrir grupo
      // console.group("Cursos de @jonmircha en youtube");
      // console.log("Curso de Javascript");
      // console.log(" curso de Node.js");
      // console.log("curso de PWAs");
      // console.log("curso de Flexbox");
      // console.log("curso de diseño y programación web");
      // // Para decirle que el grupo ha terminado hay que hacerlo con .groupEnd()
      // console.groupEnd();
      // console.groupCollapsed("Cursos de @jonmircha en youtube");
      // console.log("Curso de Javascript");
      // console.log(" curso de Node.js");
      // console.log("curso de PWAs");
      // console.log("curso de Flexbox");
      // console.log("curso de diseño y programación web");
      // // Para decirle que el grupo ha terminado hay que hacerlo con .groupEnd()
      // console.groupEnd();
      // console.clear();
      // console.table(Object.entries(console).sort());

      // const numeros = [1, 2, 3, 4, 5],
      //   vocales = ["a", "e", "i", "o", "u"];
      // console.table(numeros);
      // console.table(vocales);
      // const perro = {
      //   nombre: "Bunny",
      //   raza: "boxer",
      //   color: "cafe",
      // };
      // console.table(perro);
      // console.clear;
      // // Para calcular el tiempo que tarda en realizar dicha peticion se puede usar
      // console.time(`Cuanto tiempo tarda mi código inicio`);
      // const arreglo = Array(1000000);
      // for (let i = 0; i < arreglo.length; i++) {
      //   arreglo[i] = i;
      // }
      // // El time y el timeEnd sirven como badnera deben tener el mismo nombre para saber cuando empiezan y cuando termina es decir empieza cuando lega la lectura y termina con el timeEnd cuando este tiene la misma bandera que time y cuanto toca al End calcula cuanto ha tardado desde la lectura del time a la lectura del End
      // console.timeEnd(`Cuanto tiempo tarda mi código inicio`);
      // // console.log(arreglo);
      // console.clear();
      // // Hay veces que tambien nos gustaria saber cuantas veces se ha ejecutado cierto fragmenteo de codigo
      // // for (let i = 0; i < arreglo.length; i++) {
      // //   // console.count("codigo for");
      // //   // console.log(i);
      // // }

      // let x = 3,
      //   y = 2,
      //   PruebaXY = "Se espera que X siempre sea menor que y";
      // // El punto assert fallo cuando la condicion fallo
      // console.assert(x < y, (x, y, PruebaXY));

      // console.log(Date());
      // let fecha = new Date();
      // console.log(fecha);
      // // El getDate obtiene el dia del mes
      // console.log(fecha.getDate());
      // // getDay te da el dia de la semana- D L M Mi J V S -> 0 1 2 3 4 5 6
      // console.log(fecha.getDay());
      // // Para el mes usamos getMoth empezando desde 0->Enero 11 ->Diciembre
      // console.log(fecha.getMonth());
      // // Considera  el numero de años desde 1920 -> 2025-1925 = 125
      // console.log(fecha.getYear());
      // // Para saber el año el cuale stamos sria  con el getFullYear
      // console.log(fecha.getFullYear());
      // // Las horas
      // console.log(fecha.getHours());
      // // Los minutos
      // console.log(fecha.getMinutes());
      // // Los segundos
      // console.log(fecha.getSeconds());
      // // los milisegundos
      // console.log(fecha.getMilliseconds());
      // // Para sacar los datos a cadena de texto podemos pasarlo a toString o posteriormente toDateString
      // console.log(fecha.toString());
      // // Quedaria: Fri Jan 31
      // console.log(fecha.toDateString());
      // // Para la fecha local en string: 31/1/2025 quedaria
      // console.log(fecha.toLocaleString());
      // console.log(fecha.toLocaleDateString());
      // // La hora de modo: 10:55:21;
      // console.log(fecha.toLocaleTimeString());
      // // getTimezoneoffset -> el numero de minutos desde el meridiano que pasa por londre  que serian 0
      // console.log(fecha.getTimezoneOffset());
      // // Con UTC nos dice que fecha es alli y cuanto varian las horas respecto a UTC 0
      // console.log(fecha.getUTCDate());
      // console.log(fecha.getUTCHours());
      // console.log(Date.now());
      // // Se usa con Date no con variables, milisegundos desde el 1 de enero de 1970, usar time Stamp de hoy en milisegundos y restar la fecha de nacimiento y de ahi pasarlos a años meses dias horas minutos y segundos con el odulo por ejemplo
      // let cumpleJon = new Date(1984, 4, 23);
      // console.log(cumpleJon);
      // Math es un metodo estatico y seinvoca asi:
      // console.log(Math);
      // console.log(Math.PI);
      // // El motodo abs nos da el valor absoluto  de dicho numero
      // console.log(Math.abs(-7.8));
      // Si  queremos redondear tenemos 3 métodos para eso: ceil-> redondea al numero entero mayor, floor-> redondea al numero entero menor, round-> va a redondear al numero mas cercano pero en x,5 siempre tiende al superior
      // console.log(Math.ceil(7.8));
      // console.log(Math.floor(7.8));
      // console.log(Math.round(7.5));
      // // Raiz cuadrada
      // console.log(Math.sqrt(81));
      // // Para ppotencia , primero el numero el cual es la base y el segundo numero es tras la coma es la potencia
      // console.log(Math.pow(2, 5));
      // // Metodo saber ue sgno es(1 es positivo -1 negativo y 0 es cero)
      // console.log(Math.sign(0));
      // // Da un valor entre 0 y uno
      // console.log(Math.round(Math.random() * 1000));

      /* Corticircuito OR - cuando l valor de la izquierda en la expresión siempre pueda validar a true, es el valor que se cargara por defecto
      cortocircuito AND - cuando el valor de la izquierda en la expresio siempre pueda validar a false, es el valor que se cargara por defecto
      */
      // function saludar(nombre = "Desconocido") {
      //   nombre = nombre || "Desconocido";
      //   console.log(`Hola ${nombre}`);
      // }
      // saludar("yo");
      // saludar();
      // console.log("Cadena" || "valor de la derecha");
      // console.log(19 || "valor de la derecha");
      // console.log(true || "valor de la derecha");
      // console.log([true] || "valor de la derecha");
      // console.log({} || "valor de la derecha");
      // console.log(false || "valor de la derecha");
      // console.log(null || "valor de la derecha");
      // console.log(undefined || "valor de la derecha");
      // console.log("" || "valor de la derecha");
      // console.log(-2 || "valor de la derecha");
      // console.log(0 || "valor de la derecha");
      // console.log("************ && ***********");
      // console.log(false && "valor de la derecha");
      // console.log(null && "valor de la derecha");
      // console.log(undefined && "valor de la derecha");
      // console.log("" && "valor de la derecha");
      // console.log(-2 && "valor dela derecha");
      // console.log(0 && "valor de la derecha");
      // console.log("Cadena" || "valor de la derecha");
      // console.log(19 && "valor de la derecha");
      // console.log(true && "valor de la derecha");
      // console.log([true] && "valor de la derecha");
      // console.log({} && "valor de la derecha");
      // Cuando trabajas con react y trabasjas con componentes renderizados de componentes dinamiscos y necesitas meter uno u otro esto sirve bastante bien, se complementan y son inversos

      console.log(window);
      // window.alert("Esto es una alerta")
      // window.confirm("Hola esto es ua confirmacion");
      // window.prompt("Hola estoe s un prompt y le permite al usuario ingresar un valor")
      let alerta = alert("Esto es una alerta"),
        confirmacion = confirm("Hola esto es ua confirmacion"),
        aviso = prompt(
          "Hola esto es un aviso y le permite al usuario ingresar unv oalor"
        );
      console.log(alerta);
      console.log(confirmacion);
      console.log(aviso);
    </script>
  </body>
</html>
